Para comenzar, primero tuvimos que decidir como íbamos a admistrar las tareas. Es decir, como y donde guardamos los datos que nos permiten saber cual es la tarea actual y cual es la siguiente tarea "viva" a la que se a de permutar. También esto está estrechamente relacionado sobre como manejaríamos luego las funcionalidades de \textit{pause}, \textit{restart} y \textit{tast-by-task} (esta última explicada en la introducción del informe).\\

Decidimos entonces tener 4 variables globales:
\begin{itemize}
    \item \textit{tareas[]} que es un \textit{array} que tendrá los selectores de descriptores de tareas de cada tarea que correrá con privilegios de usuario (con los "RPL" adecuados). Habrá una relación entre la posición del selector en el \textit{array} y la tarea apuntada, en nuestro caso \textit{tareas[i]} tendrá el selector de la tarea \textit{i+1}.
    \item \textit{indiceTareaActual} nos indica cual es la tarea cuyo contexto se encuentra cargado.
    \item \textit{pause} actuará como un valor \textit{booleano} para indicarnos que la tecla 'p' del teclado ha sido presionada.
    \item \textit{step\_by\_step} tendrá la misma funcionalidad que \textit{pause}, excepto que para la tecla 's'
\end{itemize}

Todas estas variables se encuentran declaradas en el archivo \textit{sched.c}.\\

Ahora si, habiendo tomado estas decisiones, creamos una función cuya finalidad es inicilizar estos valores, la misma es \textit{inicializar\_scheduler}, y básicamente lo que hace es generar los selectores de descriptores de tareas dentro del array (manteniendo la relación mencionada más arriba) e inicializar \textit{pause} en 1 (para las tareas no empiecen a matarse al instante, sino que haya que presionar la tecla 's'. Esta funcionalidad se implementa luego), \textit{step\_by\_step} en 0 y \textit{indiceTareaActual} en 4 (esto último debido a que la función \textit{próximo\_índice} -implementada para este ejercicio- nos debería devolver el índice de la siguiente tarea, que sería 0, y queremos que eso ocurra justamente para que la tarea 1 sea la primera al comenzar la batalla).\\

Luego implementamos la función \textit{próximo\_índice}, la misma tendra una interacción muy fuerte con la rutina de atención de interrupciones del reloj y del teclado, ya que ambas se sostienen en esta función. El comportamiento de esta función, sin entrar en detalles muy técnicos, es el de retornar el selector de descriptor de \textit{TSS} correspondiente a la próxima tarea a ejecutarse y actualizar la variable global \textit{indiceTareaActual}. En caso de que no haya más tareas vivas, o el \textit{flag} de \textit{pause} este en "prendido" (es decir, que se haya presionado la tecla 'p' -tarea de la rutina de interrupción del teclado-), la función retorna el selector de la tarea \textit{IDLE}. En el caso de estar "pausados", si el \textit{flag} de \textit{step\_by\_step} es encendido, retornará el índice correspondiente a la tarea siguiente (que bien podría ser \textit{IDLE}, si no hay tareas vivas).\\

Como mencionamos, la funcionalidad de intercambio de tareas se apoya básicamente en 3 cosas: las rutinas de atención de interrupción del teclado y reloj, y de la función \textit{próximo\_índice}. Ésta última la hemos explicado, falta ver como interactúa con las interrupciones.\\

La rutina del reloj, a la hora de implementar la funcionalidad del \textit{scheduler}, básicamente lo que ha de hacer es llamar a la función \textit{próximo\_índice} y saltar a la tarea correspondiente (recordemos que esta funcion ya nos devuelve el selector del descriptor de la tarea en la GDT con la "RPL" adecuada). Tristemente, hay algunas complejidades que debemos de tener en cuenta, principalmente el hecho de que hacer un "jump" a una tarea que es la actual generaría una excepción, ya que su descriptor de \textit{TSS} va a estar marcado como \textit{busy}. Para ello, en el código \textit{asm}, realizamos comparaciones contra el registro \textit{tr} actual y realizamos la conmutación de tareas si y sólo si realmente se cambia de tarea, en caso contrario, continuamos con la ejecución del contexto actual.\\

A su vez, en la rutina del reloj es donde nos encargamos de invocar a la función \textit{actualizar\_reloj\_tareas} de manera tal de actualizar el reloj de la tarea a la que se va a conmutar.\\

En cuanto a la interrupción del teclado, simplemente agregamos al chequeo que ya habíamos hecho durante el ejercicio 5 la funcionalidad de reconocer los \textit{breakcodes} de las teclas 'p', 'r' y 's'. En el caso de la 'p', seteamos la variable global \textit{pause} en 1, y si era la 'r' la seteamos en 0. En el caso de la 's', seteamos la variable \textit{step\_by\_step} en 1 (luego la función \textit{próximo\_índice} se encargara de ponerla en 0).\\

A estas alturas ya tenemos implementado el intercambio de tareas según el reloj y el teclado. Nos faltaría hablar sobre la implementación de los servicios del \textit{kernel} y el manejo de excepciones que pueden producir las tareas.\\

Cualquier tarea, al realizar alguna operación no valida, hará que el procesador genera una excepción. En tal caso, nuestro "sistema operativo" (a.k.a. \textit{referí}) ha de eliminar a la tarea, liberar los recursos que tenía asignada y comentar cual fue el error por la pantalla. Para todas estas acciones, nos hemos apoyado en las rutinas de atención de interrupciones y en la función \textit{chuckNorris} (que mata el 100\% de gérmenes y bacterias, no como otros productos), que se encuentra implementada en el archivo \textit{sched.c}.\\

Para comenzar, lo primero que hacemos es usar macros de C y Nasm en los archivos \textit{idt.c} e \textit{isr.asm} correspondientemente. En el primero, simplemente hacemos que todas las interrupciones de la IDT apunten a una posición de memoria que se genera en el \textit{isr.asm}, y en este utilizamos un loop de Nasm para generar esas posiciones de memoria y su rutina asociada (que es la misma). Esto lo hacemos para las primeras 20 excepciones de intel. De la excepción número 0x45 y 0x46 hablaremos luego.\\

La rutina que genera el \textit{loop} del nasm, mencionada en el párrafo anterior, simplemente lo que hace es invocar a \textit{chuckNorris} (que viene porque quiere, no porque lo invoquen; a no confundir) con los parametros correspondientes.\\

La implementación de \textit{chukNorris}, lo que hace es marcar a la tarea como "muerta" de manera tal de que \textit{próximo\_índice} no la tome más en cuenta, y luego actualiza la pantalla mediante funciones de \textit{screen.c}. Esta "actualización" consiste en borrar las páginas de memoria que la tarea tenía asignadas, imprimir el mensaje de la interrupción que accionó la tarea antes de ser eliminada e imprimir el estado de los registros que tenía la tarea antes de expirar.\\

Por último, nos falta hablar de los servicios del sistema operativo y de la interrupción 0x46. Los servicios a implementar por el TP nos pedían que le permitiésemos a las tareas pedír una página de memoria de la arena y también pasarles la información de cuales éran los índices en la arena de sus páginas de código y datos actuales. Ambos servicios podían ser invocados mediante la interrupción número 0x45. Para implementarlas, creamos dos funciones: \textit{set\_page} y \textit{get\_code\_stack}.\\

\textit{get\_code\_stack} toma simplemente el registro \textit{CR3}, que en el contexto corresponde a la tarea actual (ya que las interrupciones/excepciones no accionan un cambio de contexto) y en conjunto con las direcciones virtuales TASK\_CODE y TASK\_STACK (que son las direcciones virtuales de todas las tareas) calculan cual es el índice en la arena de las páginas de la tarea. Luego devuelve estos valores mediante los registros \textit{ecx} y \textit{ebx}.\\

\textit{set\_page} chequea, antes que nada, si el índice que la tarea pidio que se le mapeara es válido. En caso de no serlo invoca a la interrupción 0x46, que es básicamente igual a las interrupciónes que ya están configuradas (de la 0 a la 19), excepto que tiene un mensaje particular correspondiendo al error. Si el índice es válido, borra de la pantalla (en la arena) la página compartida que tenía asignada -en caso de tenerla-, mapea la nueva (mediante funciones implementadas en ejercicios anteriores) y la pinta la nueva página en la pantalla.\\

Finalmente, para articular estos servicios, implementamos en el \textit{isr.asm} y el \textit{idt.c} la interrupción \textit{\_isr69} (69d = 0x45). Su implementación chequea si en el registro \textit{eax} hay algo distinto que 286 ó 386 (ambos códigos válidos de los servicios del \textit{kernel}). En caso de haber un código de servicio inválido, se desaloja a la tarea mediante la ayuda glorificadora de \textit{chuckNorris}, o sino se invoca a la función que corresponda al servicio invocado.